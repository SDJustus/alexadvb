# -*- coding: utf-8 -*-

# This is a simple Hello World Alexa Skill, built using
# the implementation of handler classes approach in skill builder.
import logging

from ask_sdk_core.skill_builder import SkillBuilder
from ask_sdk_core.dispatch_components import AbstractRequestHandler
from ask_sdk_core.dispatch_components import AbstractExceptionHandler
from ask_sdk_core.utils import is_request_type, is_intent_name
from ask_sdk_core.handler_input import HandlerInput

from ask_sdk_model.ui import SimpleCard
from ask_sdk_model import Response
import dvb
import time
from pyproj import *


sb = SkillBuilder()

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


class LaunchRequestHandler(AbstractRequestHandler):
    """Handler for Skill Launch."""
    def can_handle(self, handler_input):
        # type: (HandlerInput) -> bool
        return is_request_type("LaunchRequest")(handler_input)

    def handle(self, handler_input):
        # type: (HandlerInput) -> Response
        speech_text = "Herzlich Willkommen beim DVB Navigator!"

        handler_input.response_builder.speak(speech_text).set_card(
            SimpleCard("DVB Navigator", speech_text)).set_should_end_session(
            False)
        return handler_input.response_builder.response


class FindStationIntentHandler(AbstractRequestHandler):
# Station: Stationnamen strings
    def can_handle(self, handler_input):
        # type: (HandlerInput) -> bool
        return is_intent_name("FindStationIntent")(handler_input)

    def handle(self, handler_input):
        # type: (HandlerInput) -> Response
        session_attr = handler_input.attributes_manager.session_attributes
        slots = handler_input.request_envelope.request.intent.slots
        stop = slots["Station"].value
        
        session_attr["counter"] = 1
        time_offset = 0  # how many minutes in the future, 0 for now
        num_results = 2
        dvb_stop_answer = dvb.find(stop)
        matched_stop = dvb_stop_answer["name"]
        session_attr["stop"] = matched_stop
        speech_text = ""
        repromt = ""
        result = dvb.monitor(matched_stop, time_offset, num_results)

        if result == None:
            speech_text = "Ich habe die Haltestelle {} nicht gefunden. Bitte sag mir noch einmal den Namen der Haltestelle".format(matched_stop)
            repromt = "Bitte sag mir noch einmal den Namen der Haltestelle!"

            handler_input.response_builder.speak(speech_text).ask(repromt)
            return handler_input.response_builder.response
        else:
            speech_text = "Die naechsten Verbindungen an der Haltestelle {stop} sind: ".format(stop=matched_stop)

            for i in range(len(result)):
                line = result[i]["line"]
                direction = result[i]["direction"]
                arrival_min = ""
                if int(result[i]["arrival"]) == 1:
                    arrival_min = "einer Minute"
                else:
                    arrival_min = "{} Minuten".format(result[i]["arrival"])

                if i == len(result) - 1:
                    speech_text += "Linie {line} nach {direction} in {arrival}. ".format(
                        line=line, direction=direction, arrival=arrival_min)

                elif i == len(result) - 2:
                    speech_text += "Linie {line} nach {direction} in {arrival} und ".format(
                        line=line, direction=direction, arrival=arrival_min)

                else:
                    speech_text += "Linie {line} nach {direction} in {arrival}, ".format(
                        line=line, direction=direction, arrival=arrival_min)

            speech_text += "Möchtest du noch weitere Linien Wissen? Sag einfach \"weitere\""
            repromt += "Möchtest du noch mehr Linien wissen?"
            handler_input.response_builder.speak(speech_text).ask(repromt).set_card(
                SimpleCard("DVB Navigator", speech_text))
            return handler_input.response_builder.response

class FindMoreStationIntent(AbstractRequestHandler):
    def can_handle(self, handler_input):
        # type: (HandlerInput) -> bool
        return is_intent_name("FindMoreStationIntent")(handler_input)

    def handle(self, handler_input):
        # type: (HandlerInput) -> Response
        session_attr = handler_input.attributes_manager.session_attributes
        stop = ""
        counter = 0
        speech_text = ""
        repromt = ""
        time_offset = 0  # how many minutes in the future, 0 for now

        if "stop" in session_attr:
            stop =  session_attr["stop"]
            counter = int( session_attr["counter"]) + 1
        else:
            speech_text = "Du musst erst eine Haltestelle nennen, bevor ich dir weitere Linien an dieser sagen kann"
            repromt = "Bitte sag mir den Namen der Haltestelle."

            handler_input.response_builder.speak(speech_text).ask(repromt)
            return handler_input.response_builder.response

        num_results = 2 * counter

        result = dvb.monitor(stop, time_offset, num_results)

        speech_text = "Die naechsten Verbindungen an der Haltestelle {stop} sind: ".format(stop=stop)

        for i in range(num_results-2,len(result)):
            line = result[i]["line"]
            direction = result[i]["direction"]
            arrival_min = ""
            if int(result[i]["arrival"]) == 1:
                arrival_min = "einer Minute"
            else:
                arrival_min = "{} Minuten".format(result[i]["arrival"])

            if i == len(result) - 1:
                speech_text += "Linie {line} nach {direction} in {arrival}. ".format(
                    line=line, direction=direction, arrival=arrival_min)

            elif i == len(result) - 2:
                    speech_text += "Linie {line} nach {direction} in {arrival} und ".format(
                        line=line, direction=direction, arrival=arrival_min)

            else:
                speech_text += "Linie {line} nach {direction} in {arrival}, ".format(
                   line=line, direction=direction, arrival=arrival_min)

        speech_text += "Wenn du weitere wissen möchtest, sag einfach weitere"
        repromt += "Möchtest du noch mehr Linien wissen?"
        handler_input.response_builder.speak(speech_text).ask(repromt).set_card(
            SimpleCard("DVB Navigator", speech_text))
        return handler_input.response_builder.response

class FindTramBusByNumberIntentHandler(AbstractRequestHandler):

    def can_handle(self, handler_input):
        # type: (HandlerInput) -> bool
        return is_intent_name("FindTramBusByNumberIntent")(handler_input)

    def handle(self, handler_input):
        # type: (HandlerInput) -> Response
        slots = handler_input.request_envelope.request.intent.slots
        stop = slots["Station"].value
        line = int(slots["TramBusNumber"].value)
        time_offset = 0  # how many minutes in the future, 0 for now
        num_results = 20
        dvb_stop_answer = dvb.find(stop)
        matched_stop = dvb_stop_answer["name"]
        result = dvb.monitor(matched_stop, time_offset, num_results)
        speech_text = "Die naechsten Linien {line} an der Haltestelle {stop} sind: ".format(stop=matched_stop, line = str(line))

        if result == None:
            speech_text = "Ich habe die Haltestelle {} nicht gefunden.".format(matched_stop)
            repromt = "Bitte sag mir noch einmal die Linie und den Namen der Haltestelle!"

            handler_input.response_builder.speak(speech_text).ask(repromt)
            return handler_input.response_builder.response

        else:
            correct_List = []
            for i in range(len(result)):
                if str(line) == result[i]["line"]:
                    if len(correct_List) != 0:
                        counter = 0
                        for l in correct_List:
                            if l["line"] == result[i]["line"] and l["direction"] == result[i]["direction"]:
                                counter += 1
                        if counter == 1:
                            continue
                        else:
                            correct_List.append(result[i])
                    else:
                        correct_List.append(result[i])

            if len(correct_List) == 0:
                speech_text = "Die Linie {line} faehrt an der Haltestelle {stop} nicht!".format(line=str(line), stop=matched_stop)
                repromt = "Bitte sag mir noch einmal die Linie und den Namen der Haltestelle!"

            for i in range(len(correct_List)):
                line = correct_List[i]["line"]
                direction = correct_List[i]["direction"]
                arrival_min = ""
                if int(correct_List[i]["arrival"]) == 1:
                    arrival_min = "einer Minute"
                else:
                    arrival_min = "{} Minuten".format(correct_List[i]["arrival"])

                if i == len(correct_List) - 1:
                    speech_text += "Linie {line} nach {direction} in {arrival}.".format(
                        line=line, direction=direction, arrival=arrival_min)

                elif i == len(correct_List) - 2:
                    speech_text += "Linie {line} nach {direction} in {arrival} und ".format(
                        line=line, direction=direction, arrival=arrival_min)

                else:
                    speech_text += "Linie {line} nach {direction} in {arrival}, ".format(
                        line=line, direction=direction, arrival=arrival_min)
            handler_input.response_builder.speak(speech_text).set_card(
                SimpleCard("DVB Navigator", speech_text)).set_should_end_session(
                True)
            return handler_input.response_builder.response

class FindRouteIntentHandler(AbstractRequestHandler):
# StartStation: siehe Station
# EndStation: siehe Station
    def can_handle(self, handler_input):
        # type: (HandlerInput) -> bool
        return is_intent_name("FindRouteIntent")(handler_input)

    def handle(self, handler_input):
        # type: (HandlerInput) -> Response
        slots = handler_input.request_envelope.request.intent.slots
        origin = slots["StartStation"].value
        destination = slots["EndStation"].value
        origin_city = "Dresden"
        destination_city = "Dresden"
        time = int(time.time())
        deparr = "dep"

        result = dvb.route(origin, destination, origin_city, destination_city, time, deparr)
        speech_text = "Die naechste Moeglichkeit von {origin} nach {destination} zu kommen ist ".format(
            origin = origin, destination = destination)

        if result == None:
            speech_text = "Es gibt keine Moeglichkeit von {origin} nach {destination} zu kommen.".format(
            origin = origin, destination = destination)
            repromt = "Bitte gibt mir eine andere Route!"

            handler_input.response_builder.speak(speech_text).ask(repromt)
            return handler_input.response_builder.response

        else:
            interchange = result["trips"]["interchange"]
            interchange_response = ""
            if int(interchange) == 0:
                interchange_response = "ohne umsteigen"
            elif int(interchange) == 1:
                interchange_response = "mit einem Mal umstiegen"
            else:
                interchange_response = "mit {} Mal umsteigen".format(str(interchange))

            mode = result["trips"]["nodes"]["mode"]
            line = result["trips"]["nodes"]["line"]
            direction = result["trips"]["nodes"]["line"]
            handler_input.response_builder.speak(speech_text).set_card(
                SimpleCard("DVB Navigator", speech_text)).set_should_end_session(
                True)
            return handler_input.response_builder.response


class HelpIntentHandler(AbstractRequestHandler):
    """Handler for Help Intent."""
    def can_handle(self, handler_input):
        # type: (HandlerInput) -> bool
        return is_intent_name("AMAZON.HelpIntent")(handler_input)

    def handle(self, handler_input):
        # type: (HandlerInput) -> Response
        speech_text = "Suche einfach nach Bus und Bahnhaltestellen oder lass dir die Route zwischen 2 Haltestellen anzeigen"

        handler_input.response_builder.speak(speech_text).ask(
            speech_text).set_card(SimpleCard(
                "DVB Navigator", speech_text))
        return handler_input.response_builder.response


class CancelOrStopIntentHandler(AbstractRequestHandler):
    """Single handler for Cancel and Stop Intent."""
    def can_handle(self, handler_input):
        # type: (HandlerInput) -> bool
        return (is_intent_name("AMAZON.CancelIntent")(handler_input) or
                is_intent_name("AMAZON.StopIntent")(handler_input))

    def handle(self, handler_input):
        # type: (HandlerInput) -> Response
        speech_text = "Bis zum naechsten Mal!"

        handler_input.response_builder.speak(speech_text).set_card(
            SimpleCard("DVB Navigator", speech_text))
        return handler_input.response_builder.response


class FallbackIntentHandler(AbstractRequestHandler):
    """AMAZON.FallbackIntent is only available in en-US locale.
    This handler will not be triggered except in that locale,
    so it is safe to deploy on any locale.
    """
    def can_handle(self, handler_input):
        # type: (HandlerInput) -> bool
        return is_intent_name("AMAZON.FallbackIntent")(handler_input)

    def handle(self, handler_input):
        # type: (HandlerInput) -> Response
        speech_text = (
            "Das weiß ich leider nicht")
        reprompt = "Du kannst zum Beispiel nach Haltestellen suchen."
        handler_input.response_builder.speak(speech_text).ask(reprompt)
        return handler_input.response_builder.response


class SessionEndedRequestHandler(AbstractRequestHandler):
    """Handler for Session End."""
    def can_handle(self, handler_input):
        # type: (HandlerInput) -> bool
        return is_request_type("SessionEndedRequest")(handler_input)

    def handle(self, handler_input):
        # type: (HandlerInput) -> Response
        return handler_input.response_builder.response


class CatchAllExceptionHandler(AbstractExceptionHandler):
    """Catch all exception handler, log exception and
    respond with custom message.
    """
    def can_handle(self, handler_input, exception):
        # type: (HandlerInput, Exception) -> bool
        return True

    def handle(self, handler_input, exception):
        # type: (HandlerInput, Exception) -> Response
        logger.error(exception, exc_info=True)

        speech = "Da ist mir irgendein Fehler unterlaufen. Tut mir leid. Versuche es bitte noch einmal" + exception
        handler_input.response_builder.speak(speech).ask(speech)

        return handler_input.response_builder.response


sb.add_request_handler(LaunchRequestHandler())
sb.add_request_handler(FindStationIntentHandler())
sb.add_request_handler(FindTramBusByNumberIntentHandler())
sb.add_request_handler(FindMoreStationIntent())
sb.add_request_handler(FindRouteIntentHandler())
sb.add_request_handler(HelpIntentHandler())
sb.add_request_handler(CancelOrStopIntentHandler())
sb.add_request_handler(FallbackIntentHandler())
sb.add_request_handler(SessionEndedRequestHandler())

sb.add_exception_handler(CatchAllExceptionHandler())

handler = sb.lambda_handler()
